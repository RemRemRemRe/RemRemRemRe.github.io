[
  
  {
    "title": "我对5.6中 Unreal Animation Framework 的理解",
    "url": "/posts/My-understanding-of-Unreal-Animation-Framework-in-5.6/",
    "categories": "Unreal Engine, Animation",
    "tags": "gameplay, animation, tutorial",
    "date": "2025-08-05 01:50:00 +0800",
    "content": "约两个月前，Unreal Fest中的巫师4技术演示为我们展示了虚幻引擎下一代动画系统（Unreal Animation Framwork，下文简称UAF。同时把原来的动画蓝图系统简称为ABP），也引起了我强烈的好奇心，感觉是时候好好了解下这个系统了  本文会从程序框架的角度分析此系统 主要介绍系统的构成，各个类型的含义，它们之间的逻辑关系，希望能帮助大家理解和入手这个新动画系统 但不会涉及如动画混合的计算，或是动画重定向等细节  简单运行演示  先看一个简单的运行示例：    视频中是一个简单的分层混合效果，上半身来自拉弓动画的静帧，下半身使用循环的冲刺动画，  BlendMask使用了一个HierarchyTable:       它是一个通用的层级数据容器，这里用作BlendProfile   从左视图可以看到，两个模型完全重合，动画效果完全一致：    因为它们两个运行了相同的UAF的动画图表：       左上是下半身动画，左下是上半身动画，右边是分层混合   不同的是，左边使用了UAF框架更新上述图表：       这里的节点调用可能不是最优的实现，但用于简单的演示足够了   右边使用了ABP更新上述图表：       UAF的动画图表目前可通过这个特殊动画节点集成到动画蓝图   统一的工作区界面 Workspace  UAF接入了工作区编辑器，提供了多个资产的集成视图， 工作区自身也有一个对应资产，类型为UAF Workspace，应该是用于存放工作区相关的元数据     工作区编辑器模块来自新的实验性插件Workspace，它允许多种资产在一个统一的界面中被编辑    UAF接入了这个功能，指定了UAF相关的资产类型可以在同一个工作区下编辑    详见：UAnimNextWorkspaceSchema, IWorkspaceEditorModule::RegisterObjectDocumentType   左上角的workspace选项卡，列出了在当前工作区打开的资产：    即AG_SequencePlayer, UAFM_Module，和工作区自身的资产：UAFW_Workspace：    系统组成     以下裸cpp类型基本都位于UE::AnimNext名字空间下   UAF的逻辑载体目前由两大块组成：Module和AnimationGraph，都运行于RigVM之中，支持多线程执行      其中线程间的数据交互，通过UAnimNextComponent::PublicVariablesProxy完成  FAnimNextPublicVariablesProxy注释中有写到，目前是每帧拷贝脏标记过的数据，将来计划改成双缓冲数组(参考USkinnedMeshComponent::ComponentSpaceTransformsArray)     详见：    FAnimNextModuleInstance::CopyProxyVariables    IAnimNextVariableProxyHost::FlipPublicVariablesProxy    UAnimNextComponent::SetVariable    UAnimNextComponentWorldSubsystem::Register   Module  模块在这里是使用各个函数编写逻辑业务的地方，类似ABP里的蓝图部分/UAnimInstance::NativeUpdateAnimation,UAnimInstance::NativeThreadSafeUpdateAnimation，但更加强大，灵活  FRigUnit_AnimNextModuleEventBase：    通过基类提供的接口，每个模块可以选择是否需要独立的TickFunction，要运行在哪个Tick Group，是否运行在游戏线程等功能  UAF的编译器也会自动生成部分模块，比如变量绑定相关的FRigUnit_AnimNextExecuteBindings_GT FRigUnit_AnimNextExecuteBindings_WT  AnimationGraph  动画图表是动画逻辑及其数据的集合，类似ABP里的动画树  不一样的是，UAF里不再有各式各样的动画节点，取而代之的是一个TraitStack节点加上各种各样的Trait的组合  动画图表自身作为UObject，也承担着持有图表中共享数据的UObject对象引用，不让它们被GC的功能     详见：    UAnimNextAnimationGraph::GraphReferencedObjects    UAnimNextAnimationGraph::GraphReferencedSoftObjects   另外动画图表可以有多入口，而不只是Root  TraitStack和TraitStack节点  TraitStack：顾名思义，这是一个由Trait组成的栈结构，这个栈包含1个base trait和若干个additive trait  而与它对应的节点，只是一个正常的RigUnit节点（结构体）：    一个TraitStack节点可以包含一个或多个TraitStack  在编辑器中，就是上文分层混合图表中的样子     节点形式只是为了方便编辑器下的可视化，编译后会把对应的TraitStack序列化到动画图表中，这个RigUnit节点并不会被执行   Trait  直译为特性，理解为动画逻辑中可复用的功能，类似ABP中的动画节点，但同样的，更为强大，灵活  FTrait  FTrait是所有Trait的基类，定义了所需的基础接口，比如获取其唯一ID    子Trait由FBaseTrait或FAdditiveTrait加上ITraitInterface的子接口类组合而来，      ITraitInterface是所有trait interface的基类，    它里面只有一个获取UID的方法，即每个trait interface也有唯一ID  目前这两个唯一ID都是对类名应用FNV1a哈希算法得来， 这个算法的特点是，对于同样的字符组合，无论字符是普通字符或是宽字符，不会影响哈希结果，产生的哈希值相同，并且简单高效     详见：    FTraitUID::MakeUID    FTraitInterfaceUID::MakeUID   Trait对象本身不能有内部状态，即是无状态的，因为它们的逻辑会跑在工作线程中（比如同一帧，多个复用同一动画图表的对象，在不同的线程执行）  它的状态数据应该通过FSharedData和FInstanceData这两个类型别名来声明，UAF系统会在Trait对象外部分配好    FSharedData是同一动画图表的多个实例可以共享的只读数据，是USTRUCT，会序列化保存到文件，通常是一些硬编码的配置  FInstanceData是每个动画图表实例中的节点所需的动态数据，是裸CPP结构体     FSharedData类似于ABP中的FoldProperty，    而InstanceData的机制与StateTree中的FInstanceDataType/UInstanceDataType几乎一致   代码生成  UAF使用了一些宏，来简单快速的生成框架所需的代码，减少重复劳动  Trait Interface的宏  trait interface这边，比较简单，只有两个宏  DECLARE_ANIM_TRAIT_INTERFACE 声明并实现GetInterfaceUID，返回编译期常量：      AUTO_REGISTER_ANIM_TRAIT_INTERFACE 静态注册trait interface类的共享指针到全局trait interface注册表：    Trait的宏  Trait这边相对就复杂很多：  首先需要在trait类中使用DECLARE_ANIM_TRAIT宏，声明一些接口的覆写：    其包含的几个嵌套宏：  ANIM_NEXT_IMPL_DECLARE_ANIM_TRAIT_BASIC 声明并实现GetTraitUID，返回编译期常量；GetTraitName返回trait名字；声明TraitSuper别名  ANIM_NEXT_IMPL_DECLARE_ANIM_TRAIT_INSTANCING_SUPPORT trait数据相关的声明  ANIM_NEXT_IMPL_DECLARE_ANIM_TRAIT_INTERFACE_SUPPORT trait interface获取相关的声明  ANIM_NEXT_IMPL_DECLARE_ANIM_TRAIT_EVENT_SUPPORT trait事件相关的声明  ANIM_NEXT_IMPL_DECLARE_ANIM_TRAIT_LATENT_PROPERTY_SUPPORT Latent Property相关的声明（含义见下文Latent Property）  然后使用GENERATE_ANIM_TRAIT_IMPLEMENTATION宏，定义上述接口，    比较特别的是InterfaceEnumeratorMacro, RequiredInterfaceEnumeratorMacro, EventEnumeratorMacro这三个参数， 从名字可以看出它们是EnumeratorMacro，是用于枚举的宏，枚举的东西是它们的前缀：trait interface，必须的trait interface，trait事件  枚举宏有一个参数，也是宏，这个宏接收枚举的东西作为参数，执行相应的操作  以FBlendTwoWayTrait为例：      局部定义的TRAIT_INTERFACE_ENUMERATOR宏，枚举了FBlendTwoWayTrait实现的所有的trait interface， 并把这些接口传给了GeneratorMacro这个参数  结合GENERATE_ANIM_TRAIT_IMPLEMENTATION中嵌套的宏：  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT 定义共享数据和实例数据的内存大小和对其，构造和析构函数  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT_GET_LATENT_PROPERTY_MEMORY_LAYOUT 定义获取Latent Property的内存布局信息的函数  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT_IS_PROPERTY_LATENT 定义判定对应名字的属性是否为Latent Property的函数  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT_GET_INTERFACE 定义获取指定trait interface指针的函数  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT_GET_INTERFACES 定义获取所有实现的trait interface的ID的函数  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT_GET_REQUIRED_INTERFACES 定义获取所有必须的trait interface的ID的函数  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT_ON_TRAIT_EVENT 定义响应所需trait事件回调的函数  ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT_GET_TRAIT_EVENTS 定义获取所有响应的trait事件的ID的函数  至此，便可自动生成框架所需的trait定义  AUTO_REGISTER_ANIM_TRAIT，与AUTO_REGISTER_ANIM_TRAIT_INTERFACE类似，只不过这次注册的是trait     trait注册没有使用共享指针，而是在UE::AnimNext::TraitConstructorFunc回调传入的DestPtr地址构造   Latent Property  Latent Property是共享数据中需要实例化的部分，放在实例化数据区的后面  对于继承自FAnimNextTraitSharedData的共享数据，需要用GENERATE_TRAIT_LATENT_PROPERTIES宏，手动选择性注册需要标记为Latent Property的属性：    这个宏同样使用了枚举宏作为参数，其中它嵌套的宏：  ANIM_NEXT_IMPL_DEFINE_LATENT_CONSTRUCTOR 使用placement new，逐个构造Latent Property (内存地址的见后文FNodeInstance这节)     详见：FExecutionContext::AllocateNodeInstance 分配内存，构造实例化数据，以及Latent Property    GENERATE_ANIM_TRAIT_IMPLEMENTATION-ANIM_NEXT_IMPL_DEFINE_ANIM_TRAIT-ConstructTraitInstance    GENERATE_TRAIT_LATENT_PROPERTIES-ANIM_NEXT_IMPL_DEFINE_LATENT_CONSTRUCTOR-ConstructLatentProperties   ANIM_NEXT_IMPL_DEFINE_LATENT_DESTRUCTOR 逐个析构Latent Property  ANIM_NEXT_IMPL_DEFINE_GET_LATENT_PROPERTY_INDEX 查询对应偏移量的Latent Property下标     FAnimNextTraitSharedData::GetLatentPropertyIndex 注释中提到：如果对应偏移量的Latent Property能找到，则返回从1开始数的下标；找不到则返回Latent Property的数量，数值小于等于0（需要取负号）   ANIM_NEXT_IMPL_DEFINE_LATENT_GETTER 为每个Latent Property生成从FTraitBinding中获取属性值的getter函数     宏魔法！使用了constexpr函数GetLatentPropertyIndex获取到LatentPropertyIndex，然后从Binding中获得Latent Property引用   TraitEvent trait事件  FAnimNextTraitEvent是trait事件的基类    DECLARE_ANIM_TRAIT_EVENT 与trait和trait interface类似，声明和定义了EventUID，并且还额外支持IsA的功能，是一个简单的RTTI的替代机制     由于FAnimNextTraitEvent是USTRUCT，自定义的IsA应该不是必要的，这里可能是出于性能或其它考虑   trait事件类似UI的点击事件，可以被标记为Handled，并且可以设定有效时间或者无限时间等  全局注册表  FTraitRegistry  trait对象的全局注册表  使用宏注册trait时，FTraitRegistry 优先使用默认分配的8KB大小的StaticTraitBuffer来存放trait，超出后使用DynamicTraits存放，是一个内存局部性的优化     这里有个有趣的小细节，DynamicTraits数组存放的是uintptr_t而不是void*或者FTrait*，即选择了用整数存放指针    因为用整数，就可以同时存放数组下标，以实现后续的FreeList机制：    DynamicTraitFreeIndexHead有效时，DynamicTraits[DynamicTraitFreeIndexHead]存放的是下一个可复用的数组元素   另外还存了几个Map用于加速查询  FTraitRegistry::Register 用于注册trait到DynamicTraits  FTraitInterfaceRegistry  trait interface对象的全局注册表  对比下来，FTraitInterfaceRegistry就显得朴实无华，只是一个interface ID到智能指针的map  Node 节点     粗略的内存布局视图，用drawio绘制   这节介绍一些跟节点相关的关键类型  FNodeTemplate  一个FNodeTemplate就是一组trait的排列组合，可以有多组base + additivetrait，所有动画图表共享此模板对象    组成节点模板的trait们，以FTraitTemplate的对象形式存放在FNodeTemplate对象末尾的连续内存处       FNodeTemplateBuilder::BuildNodeTemplate 在一个TArray&lt;uint8&gt;的连续缓冲区中构造FNodeTemplate对象及其中包含的FTraitTemplate   从它可以获取UID，trait数组首地址，trait数量等信息     FNodeTemplate::NodeSharedDataSize 所有trait的共享数据（加上其中base trait的FLatentPropertiesHeader），对齐之后的大小   FNodeTemplate::NodeInstanceDataSize 所有trait的实例数据，对齐之后的大小     FTraitTemplate  FTraitTemplate就是节点模板里的trait，用它除了可以获取到关于trait的UID，trait类型，共享/实例数据，子trait数量，Latent Property数量等基本信息外，还可以获取到共享数据的偏移量，共享的latent property的数组指针偏移量以及实例数据的偏移量       详见：FNodeTemplate::Finalize      我觉得FTraitTemplate::GetTraitDescription这两个成员函数命名有点容易混淆，更好理解的命名应该是GetTraitSharedData，用于获取trait的共享数据指针，可能是笔误或者是改名了   FNodeDescription  在一个动画图表内唯一的只读数据，对象本身虽然是8字节大小，但分配内存时，加上节点上trait们的共享数据的大小，是一个用法上大小变化的对象       详见：    FTraitReader::ReadGraphSharedData    和一些其它细节： FNodeDescription::Serialize FTrait::SerializeTraitSharedData FTraitWriter::WriteNode FTrait::SaveTraitSharedData    读取之后存放在UAnimNextAnimationGraph::SharedDataBuffer，使用上参考FExecutionContext::GetNodeDescription      FNodeDescription::TemplateHandle 用于从FNodeTemplateRegistry获取FNodeTemplate对象实例   FNodeDescription::NodeInstanceDataSize 包含实例化数据的大小，加上所有Latent Property的总大小      注意FNodeDescription::NodeInstanceDataSize与FNodeTemplate::NodeInstanceDataSize的区别    另外，FNodeDescription跟FNodeTemplate是多对一的，从它们的含义上可以理解   FNodeInstance  节点的实例化数据，运行时动态创建，自身16字节大小，分配内存时，加上了trait们的实例化数据大小以及它们的Latent Property大小，也是一个用法上大小变化的对象；内置引用计数       用法上可以参考：FAnimationAnimNextRuntimeTest_TraitSerialization::RunTest，FExecutionContext::AllocateNodeInstance   FNodeTemplateRegistry  FNodeTemplate对象的全局注册表，确保了所有FNodeTemplate内存连续  FTraitStackBinding  描述一组trait（1个base trait及其children/additive trait们）所需要的数据，用于查询trait或者trait interface     详见：FTraitStackBinding::FTraitStackBinding，特别是最后几行   例如，FTraitStackBinding::GetInterfaceImpl：从trait栈上尝试找到实现了指定InterfaceUID的trait，并返回该trait的binding  FTraitBinding  描述一组trait中的特定trait的数据，可以查询当前trait是否实现了指定trait interface  TTraitBinding  强类型/类型安全的FTraitBinding  FExecutionContext  由于trait是无状态的，执行时的动态数据/实例数据需要一个对象来承载，它就是FExecutionContext，执行上下文对象  它用于绑定到一个图表实例，并为节点提供统一的trait查询接口  图表的Update和Evaluate流程封装在一个RigVM节点的执行函数中：FRigUnit_AnimNextRunAnimationGraph_v2_Execute()  FUpdateTraversalContext  更新图表时，用到的上下文子类对象  内部使用了在MemStack上分配的栈（LIFO）实现trait树的深度优先遍历，不再是ABP中的递归方式     详见：UE::AnimNext::UpdateGraph，每个trait在while循环中会被执行两次，分别对应IUpdate::PreUpdate和IUpdate::PostUpdate    IUpdate::OnBecomeRelevant也是在这里调用   FEvaluateTraversalContext  评估图表时，用到的上下文子类对象  内部的FEvaluationProgram用于存放遍历图表时，各个节点需要执行的FAnimNextEvaluationTask 随后调用FEvaluationProgram::Execute在FEvaluationVMStack上执行各评估任务     详见：UE::AnimNext::EvaluateGraph，执行流程与UpdateGraph类似   FAnimNextEvaluationTask  FAnimNextEvaluationTask是可在trait之间复用的逻辑对象，代表运行于评估虚拟机上的微指令，通过虚拟机的内部状态（也是栈）可以同时处理输入和输出  系统模块  UAF由多个模块组成：    在ue5-main分支上，系列模块的名字前缀从AnimNext改成了UAF    其中 UAF/AnimNext ：提供核心的动画工具函数，定义基类接口等。如：UE::AnimNext::FDecompressionTools::GetAnimationPose  UAFAnimGraph/AnimNextAnimGraph：实现基于RigVM的动画图表相关功能  这两个模块也是本文主要讨论的范围  其他模块则是为UAF引入其它模块/系统的功能，比如引入StateTree，PoseSearch等  SoA （struct of array）  在TransformArrayOperations.h中的每个工具函数都有AoS和SoA两个版本，并且代码中优先使用了AoS，由此可见在数据结构设计上，UAF会更面向数据一些  结论  UAF是一个重新设计的，面向数据的，倾向于组合范式的，高性能，灵活，简洁，易拓展的动画框架  完全抛弃了ABP的框架，拥抱RigVM  因其特性集尚未成熟，而处于实验性阶段  杂项  代码里写动画蓝图  参考UAFTestSuite/AnimNextTestSuite以及UAFAnimGraphTestSuite/AnimNextAnimGraphTestSuite模块中的测试用例代码  在UAF中播放“蒙太奇”  由于本文篇幅已经较长，我觉得还是不要再详细阐述了，  相关节点是UInjectionCallbackProxy，UPlayAnimCallbackProxy  相关代码在UE::AnimNext::FInjectionUtils::Inject  官方FAQ链接  Unreal Animation Framework (UAF，AnimNext) FAQ "
  },
  
  {
    "title": "如何正确获蒙太奇的蒙太奇实例",
    "url": "/posts/Get-Montage-Instance/",
    "categories": "Unreal Engine, Animation",
    "tags": "gameplay, animation, tutorial",
    "date": "2025-08-05 01:00:00 +0800",
    "content": "蒙太奇简介  蒙太奇  指的是 UAnimMontage 对象  蒙太奇实例  指的是 FAnimMontageInstance 对象  获取蒙太奇实例  GetInstanceForMontage 查找第一个匹配的蒙太奇实例  从 UAnimInstance::MontageInstances 中查找  GetActiveInstanceForMontage 查找激活的蒙太奇实例  从 UAnimInstance::ActiveMontagesMap 中查找  简易流程图    可以看到，在播放一次蒙太奇时，  在播放之后，新生成的蒙太奇实例就可以通过上述任意接口获取到,  在触发停止/开始混出之后，蒙太奇实例，不再被认为是激活的（Active），  在播放完成/蒙太奇实际停止之后，无法通过任何方式获取到。  但在短时间，多次播放同一个蒙太奇时，事情开始变得复杂了一点，  假设，播放时，bStopAllMontages为true，即停止之前播的蒙太奇。  对于GetInstanceForMontage    由于引擎的实现是 查找到第一个资源为传入蒙太奇的实例时，就返回，  那么如果MontageInstances中有正在混出的同蒙太奇实例，通过此接口拿到的只能是在混出的实例，而不是你可能需要的“激活的实例”，因为激活的实例总是加在数组末尾。这时候应该使用GetActiveInstanceForMontage  GetMontageInstanceForID 通过InstanceID查找  另外引擎提供了这个接口，来支持通过FAnimMontageInstance::InstanceID这个进程间的唯一ID来查找指定实例  建议  因为GetActiveInstanceForMontage这一个接口是通过map而不是遍历数组查询，速度最快，  如果只是需要查找正在播放且没有混出/激活 的蒙太奇实例，使用蒙太奇指针和GetActiveInstanceForMontage接口查询。  激活的蒙太奇实例最多只有一个，因为蒙太奇和蒙太奇实例是通过map一一对应的。    对于非激活蒙太奇的查找，可以考虑缓存FAnimMontageInstance::InstanceID，进行精确查找，避免多次播放相同蒙太奇时，可能找错对象的问题 "
  },
  
  {
    "title": "Latent Timer 延时定时器",
    "url": "/posts/Latent-Timer/",
    "categories": "Unreal Engine, Plugins",
    "tags": "gameplay, remcommon, tutorial, documentation",
    "date": "2024-10-05 22:35:09 +0800",
    "content": "Latent timer  既然已经有了 TimerManager，为什么还要造轮子  因为， 在用TimerManager做玩法的时候，会有不少问题:          SetTimerForNextTick 实际上是当帧触发，而不是下帧           回调顺序与定时器的设置顺序不保证一致           设置定时器时，不能指定 tick group           TimerManager::Tick 是硬编码在当帧稍晚的时刻           只支持以秒/时间单位设置延迟，你想不想用帧数来设置延迟?           不支持循环次数           尽管已经对 FTimerUnifiedDelegate 做了内存大小的优化，但FTimerDta 还是很臃肿      那我们能解决所有提到的问题么?  嗐，全解决有点难，但解决90%的问题就是小菜一碟，因为我们有个大救星 — FLatentActionManager  FLatentActionManager 是一个简单又强大的工具，用来每帧更新任意的 FPendingLatentAction 实例  每个 LatentAction 会绑定到一个 UObject， 它会在绑定对象的 tick group 更新 ! 但如果绑定对象的更新被禁用了，它就会在“接近帧末”的时刻更新，就在接近且恰好早于TimerManager::Tick的时刻  FPendingLatentAction 可以被继承，做任意你想要的事情。 例如: FDelayUntilNextTickAction， FDelayAction 它们就是蓝图中延迟节点的幕后英雄  我解决上述问题的方法：Rem::Latent::FTimerLatentAction_Delay          提供 Rem::Latent::SetTimerForThisTick 和 Rem::Latent::SetTimerForNextTick 以在表达延迟一帧的语义时，提供最大限度的明确和灵活性           Latent Action 是按照它们绑定到UObject的顺序进行处理的           Latent Action的Tick group 可以通过绑定一个在目标分组的对象上来控制。 并且顺理成章的支持指定更新依赖           支持按帧数延迟! 这个功能可能不会出现在 TimerManager。 两个辅助结构体: FTimerParameterHelper_Time， FTimerParameterHelper_Frame， 一个统一的API: Rem::Latent::SetTimer           支持指定循环次数 : FTimerParameterHelper_Time::LoopCount， FTimerParameterHelper_Frame::LoopCount           支持从下帧开始计数: 详见：FTimerParameterHelper_Time::bSkipCountingThisFrame           我的 FTimerLatentAction_Delay 只需要40字节就可以把所有任务做完了， 但 FTimerDta 有128字节， 大3.2倍!           一种 一劳永逸 的暂停定时器的替代方法：暂停一帧: Rem::Latent::SetTimerPausedOneFrame           还是熟悉的APIs: Rem::Latent::PauseTimer， Rem::Latent::UnpauseTimer， Rem::Latent::SetTimerPaused(我们之前见过吗?)， Rem::Latent::StopTimer， Rem::Latent::FindTimerAction           原生支持可重新触发的定时器: Rem::Latent::ResetTimerDelay， 同时支持按时间和帧数来延迟           调用次数补偿可以通过 FTimerParameterHelper_Time::bMaxOncePerFrame 选择性启用， (跟TimerManager一样)           目前还有27个比特是浪费的， 它们是未来的希望!      限制          Rem::Latent::FTimerHandle 是32位的， 因为 FLatentActionManager::AddNewAction 只接受 int32， 但它之前在 TimerManager是 uint64           如果你在 FLatentActionManager::ProcessLatentActions 期间对同一个对象调用了 Rem::Latent::SetTimerForThisTick 可能会发生死循环， 这种情况下，请使用 Rem::Latent::SetTimerForNextTick           如果绑定对象当帧已经更新过， Rem::Latent::SetTimerForThisTick 就不会在对应的 tick group 更新， 这种情况下，考虑使用Rem::Latent::SetTimerForNextTick           为了简单起见，TimeToDelay， LoopCount， InitialDelay 都只有4字节的大小， 将来可能会考虑用上那些空闲的比特位           需要绑定的对象启用每帧更新，以支持给我们的定时器指定tick group      实例代码  void UYourObject::DoJob() {     auto TimerHandle = Rem::Latent::SetTimerForThisTick(*this,         FTimerDelegate::CreateUObject(this, &amp;ThisClass::Callback)); }   void UYourObject::TryDoJobUntilSucceed() {     bool bWantToRetry{true};      ON_SCOPE_EXIT     {         if (bWantToRetry)         {             Rem::Latent::SetTimerForNextTick(*this, FTimerDelegate::CreateWeakLambda(this,             [this]             {                 TryDoJobUntilSucceed();             }));         }     };      // ... }   void UYourObject::RetriggerableJob() {     // ...      if (!TimerHandle.IsValid())     {         TimerHandle = Rem::Latent::SetTimer(*this, FTimerDelegate::CreateWeakLambda(this, [this]         {             // ...             Rem::Latent::StopTimer(*this, TimerHandle);             TimerHandle = {};         }), {.TimeToDelay = 1.0f, .LoopCount = 0/*loop infinite*/});     }     else     {         Rem::Latent::ResetTimerDelay(*this, TimerHandle);     } }  "
  },
  
  {
    "title": "Re:从零开始的RemGameplayCamera",
    "url": "/posts/RemGameplayCamera-from-zero/",
    "categories": "Unreal Engine, Plugins",
    "tags": "gameplay, remgameplaycamera, tutorial, documentation",
    "date": "2024-10-05 20:55:20 +0800",
    "content": "前言  本文是 RemGameplayCamera 插件的简单明了的入门教程  它将涵盖使用该插件所需的基础知识。  希望你会喜欢  (我会持续改进本文，欢迎任何反馈或者贡献)  介绍  RemGameplayCamera 插件是为虚幻引擎打造的一个数据驱动的玩法相机系统。它提供了基于状态（Tag）的，模块化的，具有优先级的相机数据配置，使用数据资产，支持实时编辑  基于引擎已有的相机框架之上搭建，让它完全兼容原生的相机序列，相机抖动，观看对象切换以及其他相机效果  他是基于AActor的，所以任意的AActor子类对象都可以接入，（当前 UAbilitySystemComponent 是必需的）  因为有内置的相机位置，旋转平滑及其他许多机制，只需要调整相机配置，就可以轻易的实现像 ALS 或者 Lyra 中那样的相机效果，不需要写一行代码  它内置了很多相关的基础功能，比如自由视角， 敌人锁定， 模型渐隐 和 后处理管理等，并且支持自定义拓展  相机数据处理管线被分成了多个部分，每个部分都可以通过蓝图或者代码自由拓展！  你可以很容易的实现像 基于速度的FOV， 基于速度的相机偏移量等功能  注意：当前此插件依赖观看对象上的技能组件来提供基于状态事件驱动的相机数据更新机制。同时也通过这种方法，让相机与游戏世界中的其它部分解耦开来  0. 从 第三人称模板 开始  其实不是从零开始😀， 我将引导你做一个关于 RemGameplayCamera 的简单演练：替换第三人称模板中的默认相机  1. 拷贝 Config 目录中的文件到你的项目  假定你已经创建了 Third Person project 并且把 RemGameplayCamera 放进了插件目录里  请拷贝 RemGameplayCamera/Config 文件夹到 YourProject/Config 文件夹， 它们是相机系统的默认 GameplayTag 配置。他们会把默认的标签注册到系统中，并且自动配置好 URemCameraSettings 对象  你可以在编辑器启动之后，去Project Settings -&gt; Game -&gt; Rem Camera Settings 检查配置是否生效。或者自定义它们，如果你想要的话  2. 对第三人称角色选择性启用  默认情况下，rem camera system 对每个观看对象都是禁用的  想要使用此系统的观看对象，需要在它们的AActor::Tags属性中，写入RemTickCamera这个名字，以便被正常识别  因此，现在打开 BP_ThirdPersonCharacter， 然后从细节面板中添加它:   3. 创建必需的文件  为了使用 rem camera system，我们需要使用 ARemPlayerCameraManager，并为它准备好 相机数据  创建 BP_RemCameraManager  所以，首先，让我们创建相机管理器蓝图，是它调度着整个系统，取名为”BP_RemCameraManager”，继承自ARemPlayerCameraManager  创建 BP_PlayerController  为了使用 BP_RemCameraManager， 创建一个玩家控制器蓝图，取名为”BP_PlayerController”， 继承自APlayerController，并且指定”BP_RemCameraManager” 到它的 Player Camera Manager Class 属性:   创建 BP_GameMode  为了使用 BP_PlayerController， 创建一个游戏模式蓝图，取名为”BP_GameMode”， 继承自AYourProjectNameGameMode，并且指定”BP_PlayerController” 到它的 Player Controller Class 属性:   创建相机数据文件  BP_RemCameraManager 需要 相机数据 以便正常工作  相机数据通过一个简单的层级组织起来：    URemCameraSettingForViewTargets 拥有游戏中所有可观看对象的相机配置。 被 ARemPlayerCameraManager引用着。 这是层级中的顶层或者说根节点   URemCameraSettingAssetsForViewTarget 拥有一种类型的观看对象的相机配置。 被 URemCameraSettingForViewTargets引用着   URemCameraSettingAsset 是具体的相机配置数据所在的地方。 被URemCameraSettingAssetsForViewTarget引用着   创建 DA_Camera_Setting  首先，我们创建一个数据资产， 取名为 DA_Camera_Setting， 拥有URemCameraSettingAsset类型  复制下面的数据，粘贴到State Query property:  (TokenStreamVersion=0,TagDictionary=,QueryTokenStream=(0,1,6,1,1,0),UserDescription=\"\",AutoDescription=\" NONE(  ANY( ) )\")  它会让 tag query（状态查询/标签查询） 总是匹配的， 以便让我们的相机配置资产总是生效     通常，这里应该匹配特定观看对象的状态，这些状态是用标签表示的   然后，复制下面的数据，粘贴到Setting Values 属性:  ((Comment=\"CameraSettingValue.CameraTransform.Location.Offset\",SettingTag=(TagName=\"CameraSettingValue.CameraTransform.Location.Offset\"),Value=/Script/RemGameplayCamera.RemCameraDataLocationOffset_Fixed(Offset=(X=280.000000,Y=0.000000,Z=0.000000))),(Comment=\"CameraSettingValue.Fov.Value\",SettingTag=(TagName=\"CameraSettingValue.Fov.Value\"),Value=/Script/RemGameplayCamera.RemCameraDataFov_Fixed(Fov=90.000000)),(Comment=\"CameraSettingValue.PivotTransform.Value\",SettingTag=(TagName=\"CameraSettingValue.PivotTransform.Value\"),Value=/Script/RemGameplayCamera.RemCameraDataTransform_MeshTransform(SocketName=\"spine_05\",Offset=(X=0.000000,Y=0.000000,Z=0.000000))),(Comment=\"CameraSettingValue.Trace\",SettingTag=(TagName=\"CameraSettingValue.Trace\"),Value=/Script/RemGameplayCamera.RemCameraDataTrace_Collision(TraceRadius=15.000000,TraceDistanceRatioInterpolationSpeed=10.000000,TraceStartLocationAlpha=(Curve=(),BlendTime=1.000000),TraceStartTransform=None)),(Comment=\"CameraSettingValue.CameraTransform.Location.Blend\",SettingTag=(TagName=\"CameraSettingValue.CameraTransform.Location.Blend\"),Value=/Script/RemGameplayCamera.RemCameraDataBlendAlpha_Blend(Blend=/Script/RemGameplayCamera.RemCameraAlphaBlend(Blend=(Curve=(),BlendTime=1.000000)))))   这些数据尝试模拟BP_ThirdPersonCharacter的相机臂的配置  创建 DA_Camera_ViewTarget  既然具体的配置数据准备好了，我们将要创建另一种数据资产，取名为 DA_Camera_ViewTarget， 拥有URemCameraSettingAssetsForViewTarget类型。 它指定了要给我们的角色使用的配置数据资产  对于 View Target Tag Query 属性， 我们将会使用跟上面👆   DA_Camera_Setting::State Query一样的值，因为我们希望它可以匹配成功并被使用     通常，这里应该匹配特定观看对象的识别码，它也是用标签表示的   然后在SettingAssetsForStatesData中添加一个元素，并把 DA_Camera_Setting 添加到它的 SettingAssets 属性 （bUseSettingAssetsGroups是新增的较高级功能，这里我们先忽略，让它保持未勾选状态，以使用与之相对的简单功能，后文会有对其的详细使用说明）  创建 DA_Camera_ViewTargets  最后，我们创建最后一个数据资产，取名为 DA_Camera_ViewTargets， 拥有 URemCameraSettingForViewTargets类型。 它有着游戏中所有观看对象的相机配置的引用  添加 DA_Camera_ViewTarget 到它的 Settings for View Targets 属性， 完成  最后但同样重要的， 指定 DA_Camera_ViewTargets 到 BP_RemCameraManager::CameraSettingForViewTargets属性    4. PIE，启动！  在把游戏模式换成 BP_GameMode 后， 点击开始按钮  你可能会发现相机正跟着角色的脊柱运动，比较明显的是观察它落地的时候。另外，相机在远离发生碰撞的物体时，会有一个平滑过渡的过程，跟ALS中的表现类似  在控制台输入命令：Rem.Camera.DrawDebug.Shape 1， 一个蓝色的球体会显示在角色的脊柱附近，它代表着Pivot Location（枢纽点，支点），这点也跟ALS一样    5. 祝贺您完成教程  感谢您花时间阅读本文  ♥  继续深入？  相机位置是如何计算的    👆 这张图片包含了一些便于理解这个系统的关键用语，当你感到困惑的时候，可以随时参考它，或者在我们的群里提问求助。  相机管线中需要的每份数据都可以被自由拓展  每份数据都为你内置了不少相关的功能，请自由探索它们     想知道更多信息，请查看 URemCameraSettings 和 FRemCameraSettingTagValue 的浮动提示   SettingAssetsForStatesData 同一观看对象的细分状态配置  在3.2版本之前，一种观看对象的配置资产中有且仅有一组相机配置  当观看对象在不同状态下都有不同的相机配置时，需要把所有相机配置都列入其中，难以维护和使用  现在可以分别为每种组合状态配置一组相机配置。组合态变化时，会自动切换配置，从而解决了上面两个问题  比如：为不同的移动模式分别配置一组配置，而不是把所有移动模式的相机配置都配在一个数组里。     当然没人阻止你这么做，但显然前者从长远来看会更好   勾选 bUseSettingAssetsGroups 以使用配置分组功能  在3.2版本，我在SettingAssetsForStatesData中添加了SettingAssetsGroups属性，以支持相机配置在观看对象的不同状态下复用  使用URemCameraSettingAssetGroup类型，将相机配置自由组合，得到想要的一组相机配置  每个配置分组可以选择将一个配置子分组加在当前这组相机配置的最前面或者最后面，或者指定相机配置的前面或者后面    修改引擎，以支持配置类型的过滤  需要联系我获取源码仓库的访问权限，因为必需修改引擎和插件的代码  操作步骤：     将仓库的根目录中的patch应用到引擎   编辑插件代码中的REM_ENABLE_CAMERA_DATA_DROP_DOWN_FILTER宏为true   即可获得自动根据选中的相机配置Tag过滤指定相机数据类型的数据：    可以看到上图中，只列出了变换相关的数据 "
  },
  
  {
    "title": "简析FGameplayTagQuery",
    "url": "/posts/Inside-FGameplayTagQuery/",
    "categories": "Unreal Engine",
    "tags": "gameplay",
    "date": "2023-11-13 01:13:14 +0800",
    "content": "什么是FGameplayTagQuery  引用自源码注释:     FGameplayTagQuery是可以查询FGameplayTagContainer中的一组Tag是否满足特定条件的一组逻辑表达式. 一个匹配成功的query则表示对应的tag container是满足条件的. 其中逻辑表达式支持”与,或,非”,以及嵌套的子表达式. 在内部,它将这些逻辑表达式以字节流的形式表达,实现内存上的高效率,并且运行时可以快速检验   为什么要使用FGameplayTagQuery  因为使用FGameplayTagQuery进行逻辑匹配时,tag数量和匹配逻辑都可以是任意的,且支持逻辑嵌套,而不像:    FGameplayTag限定了只能用1个tag(虽然除了本身,也可以用于匹配父级tag)   FGameplayTagContainer只有有限的匹配逻辑(与,或,非中的哪种匹配逻辑,取决于代码如何使用)   FGameplayTagRequirements在未加入FGameplayTagRequirements::TagQuery成员之前,它只有两个FGameplayTagContainer成员,对应了”与”,”非”的匹配逻辑,依然有限(在TagQuery成员加入的改动之后,可以用FGameplayTagRequirements::ConvertTagFieldsToTagQuery获得两个tag container逻辑合并之后的Query对象)   FGameplayTagQuery原理  数据结构          TokenStreamVersion 版本号,保留数据以便于处理后续可能的实现方式变更,对应枚举类型EGameplayTagQueryStreamVersion           TagDictionary 去重后的tag数组,来自于逻辑表达式中需要用到的tag           QueryTokenStream 一组元数据,存储了版本号(冗余存储),是否有逻辑表达式表达式,逻辑表达式类型,用到的tag数量,以及每个用到的tag在TagDictionary中的下标.是实现内存紧凑和性能高效的关键           UserDescription 字符串,自定义的描述信息           AutoDescription 字符串,自动生成的描述信息      生成方式  使用C++构造query对象  使用建造者模式的API,来进行逻辑表达式的构建: \tFGameplayTagQuery TagQuery; \tconst FGameplayTagContainer TagContainerA{}; \tconst FGameplayTagContainer TagContainerB{}; \tconst FGameplayTag TagC{};  \tTagQuery.Build(FGameplayTagQueryExpression().AllExprMatch() \t\t.AddExpr(FGameplayTagQueryExpression().AnyTagsMatch().AddTags(TagContainerA)) \t\t.AddExpr(FGameplayTagQueryExpression().NoExprMatch() \t\t\t\t.AddExpr(FGameplayTagQueryExpression().NoTagsMatch().AddTags(TagContainerB)) \t\t\t\t.AddExpr(FGameplayTagQueryExpression().AnyTagsMatch().AddTag(TagC))), FString{TEXTVIEW(\"Test Logic\")});      // 随便写的逻辑,不建议尝试理解它     // 我用缩进层级表示嵌套层级,每层中的一行定义了一个逻辑表达式   FGameplayTagQuery::Build简略流程:    写入版本号和用户描述信息,重置关键数据   对QueryTokenStream的第0和1号元素写入”版本号”和”是否含有逻辑表达式”的信息   对逻辑表达式进行解析,在QueryTokenStream中写入表达式类型的枚举,对应EGameplayTagQueryExprType,对于”非嵌套表达式”类型,写入它用到的tag数量,将每个tag去重添加到TagDictionary,并写入下标;对于”嵌套表达式”类型,递归解析   简单来说,Build流程使用深度优先遍历将树形结构的逻辑表达式,平铺成了数组.  使用编辑器构造query对象  底层逻辑与使用C++构造一致,只不过由于FGameplayTagQueryExpression不是USTRUCT,以及当时InstancedStruct还没诞生,所以对它用UObject”镜像”了一遍(个人猜测),所以有了UEditableGameplayTagQueryExpression以及相关类型,以支持编辑时的表达式嵌套,提供了更好的调试信息,参照FGameplayTagQuery::BuildFromEditableQuery  FGameplayTagQuery::Matches, 检验逻辑表达式  使用了辅助类型FQueryEvaluator,持有TagQuery的不可变引用,记录当前元数据下标和检测是否有读取错误.根据读取到的表达式类型,执行对应的逻辑判定.每次读取元数据都会检测是否存在读取错误.参照FQueryEvaluator::EvalExpr  结语 感觉FGameplayTagQuery的实现比较巧妙,提供了强大的匹配逻辑,适合任意需要Tag匹配功能的需求,不过其中的编辑器逻辑存在代码重复,不够优雅,以及对读取错误的检测并不严谨,后续频繁的检测也就不太必要了.但总体上瑕不掩瑜 "
  },
  
  {
    "title": "一种把多个虚幻工程解决方案合而为一的方法",
    "url": "/posts/A-way-to-combine-multiple-unreal-projects-into-one/",
    "categories": "Unreal Engine",
    "tags": "tooling",
    "date": "2022-06-05 11:15:13 +0800",
    "content": "使用引擎目录的GenerateProjectFiles.bat和.uprojectdirs文件     首先参考Default.uprojectdirs文件中的注释   新建my.uprojectdirs或直接修改Default.uprojectdirs文件,并写入例如Project/   此时运行GenerateProjectFiles.bat生成解决方案时,会额外从引擎目录/Project目录下的1级子目录寻找虚幻工程目录, 例如UnrealEngine/Project/LyraGame   完成      因为.uprojectdirs文件中只支持指定子目录,若想要外部目录的工程也被包含进解决方案文件,可以使用系统提供的symbol-link功能       已废弃方法    初衷    因为工作,学习的原因,我本地会有多个虚幻工程,并且它们共用了同一个引擎    它们的工程文件默认都是由UBT(Unreal Build Tool)生成的,独立的解决方案文件    这给我带来的一些问题:                由于打开解决方案的成本较高,同时打开多个解决方案时的等待时间,内存占用可能都是成倍增加的                 在IDE抽风,或者引擎代码更新而触发符号重新解析的时候,等待时间少则15分钟起步,那叫一个折磨            我认为不同解决方案中,物理路径相同的工程,应该视为同一个工程,虚幻引擎的工程不应该在每个解决方案都重新解析一遍    但目前用过的Rider和Visual Studio(宇宙第一IDE)都是会在每个解决方案中重新解析一遍.非常折磨,其中原由,令人费解,希望能有大佬告知一下    需求    所以我就在想,既然这些个IDE这么”愚笨”,靠不住,那我能否找到一个方法,手动把多个解决方案合成一个呢?    步骤    下面分享的是,我使用Rider时的操作步骤:                在想要多开的解决方案中,随意选择一个作为”主解决方案“,并打开                 添加其它工程文件                        在Explorer解决方案浏览器中,右键任意工程文件夹,比如Games,选择Add,Add Existing Project...,然后选择相关的工程文件                 假如要添加的工程是LyraStarterGame,那么它的工程文件应该位于LyraStarterGame_Folder\\\\Intermediate\\\\ProjectFiles\\\\LyraStarterGame.vcxproj                 在”解决方案配置”中,修改刚刚添加的工程的配置                   点击右上角的工具栏中的DebugGameEditor | Win64按钮(这是我的解决方案编译配置,根据你的实际情况,文字会有所不同),然后选择Edit Solution Comfigurations...                 找到刚刚添加的工程,可以看到它们当前都是默认的配置,可能是DebugClient | Arm64什么的,把它改成你需要的配置,一般是与解决方案编译配置一致                 修改工程文件参数                   回到Explorer解决方案浏览器                 右键刚刚添加的工程(这里我拿LyraStarterGame举例),选择Edit,Edit LyraStarterGame.vcxproj                 将LyraStarterGame.vcxproj文件中所有$(SolutionDir)替换为$(ProjectDir)..\\\\..\\\\ ($(SolutionDir)是当前解决方案的根目录,$(ProjectDir)是当前工程的工程文件所在目录,即LyraStarterGame_Folder\\\\Intermediate\\\\ProjectFiles\\\\,所以这里使用两次..\\\\,获得了当前工程的根目录)                 如果不想一次性全都替换,也可以搜索你的”编译配置“,比如 DebugGame_Editor|x64,找到对应编译配置的相关配置,只替换三个NMake相关的命令行中的文本,但可能会存在工程文件无法正常解析符号的问题:比如Switch Header/Source功能无法使用,语法着色失效等,如遇到问题,进行全量替换即可            不足    每次通过UBT重新生成解决方案文件时,相关的工程文件会被覆盖,上面的操作需要重新执行一次.如果能有IDE的支持,或者自动化的工具就好了    "
  }
  
]

