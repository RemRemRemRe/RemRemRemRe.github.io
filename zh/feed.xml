

<feed xmlns="http://www.w3.org/2005/Atom">
  <id>https://remremremre.github.io/</id>
  <title>RemRemRemRe</title>
  <subtitle>Sharing something useful to the world :)</subtitle>
  <updated>2025-08-18T04:02:00+08:00</updated>
  <author>
    <name>RemRemRemRe</name>
    <uri>https://remremremre.github.io/</uri>
  </author>
  <link rel="self" type="application/atom+xml" href="https://remremremre.github.io/feed.xml"/>
  <link rel="alternate" type="text/html" hreflang="en"
    href="https://remremremre.github.io/"/>
  <generator uri="https://jekyllrb.com/" version="4.4.1">Jekyll</generator>
  <rights> © 2025 RemRemRemRe </rights>
  <icon>/assets/img/favicons/favicon.ico</icon>
  <logo>/assets/img/favicons/favicon-96x96.png</logo>


  
  <entry>
    <title>我对5.6中 Unreal Animation Framework 的理解</title>
    <link href="https://remremremre.github.io/posts/My-understanding-of-Unreal-Animation-Framework-in-5.6/" rel="alternate" type="text/html" title="我对5.6中 Unreal Animation Framework 的理解" />
    <published>2025-08-05T01:50:00+08:00</published>
  
    <updated>2025-08-05T01:50:00+08:00</updated>
  
    <id>https://remremremre.github.io/posts/My-understanding-of-Unreal-Animation-Framework-in-5.6/</id>
    <content type="text/html" src="https://remremremre.github.io/posts/My-understanding-of-Unreal-Animation-Framework-in-5.6/" />
    <author>
      <name>RemRemRemRe</name>
    </author>

  
    
    <category term="Unreal Engine" />
    
    <category term="Animation" />
    
  

  <summary>约两个月前，Unreal Fest中的巫师4技术演示为我们展示了虚幻引擎下一代动画系统（Unreal Animation Framwork，下文简称UAF。同时把原来的动画蓝图系统简称为ABP），也引起了我强烈的好奇心，感觉是时候好好了解下这个系统了  本文会从程序框架的角度分析此系统 主要介绍系统的构成，各个类型的含义，它们之间的逻辑关系，希望能帮助大家理解和入手这个新动画系统 但不会涉及如动画混合的计算，或是动画重定向等细节  简单运行演示  先看一个简单的运行示例：    视频中是一个简单的分层混合效果，上半身来自拉弓动画的静帧，下半身使用循环的冲刺动画，  BlendMask使用了一个HierarchyTable:       它是一个通用的层级数据容器，这里用作BlendProfile   从左视图可以看到，两个模型完全重合，动画效果完全一致：    因为它们两个运行了相同...</summary>

  </entry>

  
  <entry>
    <title>如何正确获蒙太奇的蒙太奇实例</title>
    <link href="https://remremremre.github.io/posts/Get-Montage-Instance/" rel="alternate" type="text/html" title="如何正确获蒙太奇的蒙太奇实例" />
    <published>2025-08-05T01:00:00+08:00</published>
  
    <updated>2025-08-05T01:00:00+08:00</updated>
  
    <id>https://remremremre.github.io/posts/Get-Montage-Instance/</id>
    <content type="text/html" src="https://remremremre.github.io/posts/Get-Montage-Instance/" />
    <author>
      <name>RemRemRemRe</name>
    </author>

  
    
    <category term="Unreal Engine" />
    
    <category term="Animation" />
    
  

  <summary>蒙太奇简介  蒙太奇  指的是 UAnimMontage 对象  蒙太奇实例  指的是 FAnimMontageInstance 对象  获取蒙太奇实例  GetInstanceForMontage 查找第一个匹配的蒙太奇实例  从 UAnimInstance::MontageInstances 中查找  GetActiveInstanceForMontage 查找激活的蒙太奇实例  从 UAnimInstance::ActiveMontagesMap 中查找  简易流程图    可以看到，在播放一次蒙太奇时，  在播放之后，新生成的蒙太奇实例就可以通过上述任意接口获取到,  在触发停止/开始混出之后，蒙太奇实例，不再被认为是激活的（Active），  在播放完成/蒙太奇实际停止之后，无法通过任何方式获取到。  但在短时间，多次播放同一个蒙太奇时，事情开始变得复杂了一点，  假设，播...</summary>

  </entry>

  
  <entry>
    <title>Latent Timer 延时定时器</title>
    <link href="https://remremremre.github.io/posts/Latent-Timer/" rel="alternate" type="text/html" title="Latent Timer 延时定时器" />
    <published>2024-10-05T22:35:09+08:00</published>
  
    <updated>2024-10-06T01:06:02+08:00</updated>
  
    <id>https://remremremre.github.io/posts/Latent-Timer/</id>
    <content type="text/html" src="https://remremremre.github.io/posts/Latent-Timer/" />
    <author>
      <name>RemRemRemRe</name>
    </author>

  
    
    <category term="Unreal Engine" />
    
    <category term="Plugins" />
    
  

  <summary>Latent timer  既然已经有了 TimerManager，为什么还要造轮子  因为， 在用TimerManager做玩法的时候，会有不少问题:          SetTimerForNextTick 实际上是当帧触发，而不是下帧           回调顺序与定时器的设置顺序不保证一致           设置定时器时，不能指定 tick group           TimerManager::Tick 是硬编码在当帧稍晚的时刻           只支持以秒/时间单位设置延迟，你想不想用帧数来设置延迟?           不支持循环次数           尽管已经对 FTimerUnifiedDelegate 做了内存大小的优化，但FTimerDta 还是很臃肿      那我们能解决所有提到的问题么?  嗐，全解决有点难，但解决90%的问题就是小菜一碟，因为我...</summary>

  </entry>

  
  <entry>
    <title>Re:从零开始的RemGameplayCamera</title>
    <link href="https://remremremre.github.io/posts/RemGameplayCamera-from-zero/" rel="alternate" type="text/html" title="Re:从零开始的RemGameplayCamera" />
    <published>2024-10-05T20:55:20+08:00</published>
  
    <updated>2025-03-19T01:37:29+08:00</updated>
  
    <id>https://remremremre.github.io/posts/RemGameplayCamera-from-zero/</id>
    <content type="text/html" src="https://remremremre.github.io/posts/RemGameplayCamera-from-zero/" />
    <author>
      <name>RemRemRemRe</name>
    </author>

  
    
    <category term="Unreal Engine" />
    
    <category term="Plugins" />
    
  

  <summary>前言  本文是 RemGameplayCamera 插件的简单明了的入门教程  它将涵盖使用该插件所需的基础知识。  希望你会喜欢  (我会持续改进本文，欢迎任何反馈或者贡献)  介绍  RemGameplayCamera 插件是为虚幻引擎打造的一个数据驱动的玩法相机系统。它提供了基于状态（Tag）的，模块化的，具有优先级的相机数据配置，使用数据资产，支持实时编辑  基于引擎已有的相机框架之上搭建，让它完全兼容原生的相机序列，相机抖动，观看对象切换以及其他相机效果  他是基于AActor的，所以任意的AActor子类对象都可以接入，（当前 UAbilitySystemComponent 是必需的）  因为有内置的相机位置，旋转平滑及其他许多机制，只需要调整相机配置，就可以轻易的实现像 ALS 或者 Lyra 中那样的相机效果，不需要写一行代码  它内置了很多相关的基础功能，比如自由视...</summary>

  </entry>

  
  <entry>
    <title>简析FGameplayTagQuery</title>
    <link href="https://remremremre.github.io/posts/Inside-FGameplayTagQuery/" rel="alternate" type="text/html" title="简析FGameplayTagQuery" />
    <published>2023-11-13T01:13:14+08:00</published>
  
    <updated>2023-11-13T01:13:14+08:00</updated>
  
    <id>https://remremremre.github.io/posts/Inside-FGameplayTagQuery/</id>
    <content type="text/html" src="https://remremremre.github.io/posts/Inside-FGameplayTagQuery/" />
    <author>
      <name>RemRemRemRe</name>
    </author>

  
    
    <category term="Unreal Engine" />
    
  

  <summary>什么是FGameplayTagQuery  引用自源码注释:     FGameplayTagQuery是可以查询FGameplayTagContainer中的一组Tag是否满足特定条件的一组逻辑表达式. 一个匹配成功的query则表示对应的tag container是满足条件的. 其中逻辑表达式支持”与,或,非”,以及嵌套的子表达式. 在内部,它将这些逻辑表达式以字节流的形式表达,实现内存上的高效率,并且运行时可以快速检验   为什么要使用FGameplayTagQuery  因为使用FGameplayTagQuery进行逻辑匹配时,tag数量和匹配逻辑都可以是任意的,且支持逻辑嵌套,而不像:    FGameplayTag限定了只能用1个tag(虽然除了本身,也可以用于匹配父级tag)   FGameplayTagContainer只有有限的匹配逻辑(与,或,非中的哪种匹配逻辑,...</summary>

  </entry>

</feed>


