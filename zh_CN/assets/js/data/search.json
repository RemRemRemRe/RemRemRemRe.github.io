[
  
  {
    "title": "解析FGameplayTagQuery",
    "url": "/posts/Inside-FGameplayTagQuery/",
    "categories": "Unreal Engine",
    "tags": "gameplay",
    "date": "2023-11-13 01:13:14 +0800",
    





    
    "snippet": "什么是FGameplayTagQuery引用自源码注释:  FGameplayTagQuery是可以查询FGameplayTagContainer中的一组Tag是否满足特定条件的一组逻辑表达式. 一个匹配成功的query则表示对应的tag container是满足条件的. 其中逻辑表达式支持”与,或,非”,以及嵌套的子表达式. 在内部,它将这些逻辑表达式以字节流的形式表达,实现内存上的高效率...",
    "content": "什么是FGameplayTagQuery引用自源码注释:  FGameplayTagQuery是可以查询FGameplayTagContainer中的一组Tag是否满足特定条件的一组逻辑表达式. 一个匹配成功的query则表示对应的tag container是满足条件的. 其中逻辑表达式支持”与,或,非”,以及嵌套的子表达式. 在内部,它将这些逻辑表达式以字节流的形式表达,实现内存上的高效率,并且运行时可以快速检验为什么要使用FGameplayTagQuery因为使用FGameplayTagQuery进行逻辑匹配时,tag数量和匹配逻辑都可以是任意的,且支持逻辑嵌套,而不像:  FGameplayTag限定了只能用1个tag(虽然除了本身,也可以用于匹配父级tag)  FGameplayTagContainer只有有限的匹配逻辑(与,或,非中的哪种匹配逻辑,取决于代码如何使用)  FGameplayTagRequirements在未加入FGameplayTagRequirements::TagQuery成员之前,它只有两个FGameplayTagContainer成员,对应了”与”,”非”的匹配逻辑,依然有限(在TagQuery成员加入的改动之后,可以用FGameplayTagRequirements::ConvertTagFieldsToTagQuery获得两个tag container逻辑合并之后的Query对象)FGameplayTagQuery原理数据结构      TokenStreamVersion 版本号,保留数据以便于处理后续可能的实现方式变更,对应枚举类型EGameplayTagQueryStreamVersion        TagDictionary 去重后的tag数组,来自于逻辑表达式中需要用到的tag        QueryTokenStream 一组元数据,存储了版本号(冗余存储),是否有逻辑表达式表达式,逻辑表达式类型,用到的tag数量,以及每个用到的tag在TagDictionary中的下标.是实现内存紧凑和性能高效的关键        UserDescription 字符串,自定义的描述信息        AutoDescription 字符串,自动生成的描述信息  生成方式使用C++构造query对象使用建造者模式的API,来进行逻辑表达式的构建:\tFGameplayTagQuery TagQuery;\tconst FGameplayTagContainer TagContainerA{};\tconst FGameplayTagContainer TagContainerB{};\tconst FGameplayTag TagC{};\tTagQuery.Build(FGameplayTagQueryExpression().AllExprMatch()\t\t.AddExpr(FGameplayTagQueryExpression().AnyTagsMatch().AddTags(TagContainerA))\t\t.AddExpr(FGameplayTagQueryExpression().NoExprMatch()\t\t\t\t.AddExpr(FGameplayTagQueryExpression().NoTagsMatch().AddTags(TagContainerB))\t\t\t\t.AddExpr(FGameplayTagQueryExpression().AnyTagsMatch().AddTag(TagC))), FString{TEXTVIEW(\"Test Logic\")});    // 随便写的逻辑,不建议尝试理解它    // 我用缩进层级表示嵌套层级,每层中的一行定义了一个逻辑表达式FGameplayTagQuery::Build简略流程:  写入版本号和用户描述信息,重置关键数据  对QueryTokenStream的第0和1号元素写入”版本号”和”是否含有逻辑表达式”的信息  对逻辑表达式进行解析,在QueryTokenStream中写入表达式类型的枚举,对应EGameplayTagQueryExprType,对于”非嵌套表达式”类型,写入它用到的tag数量,将每个tag去重添加到TagDictionary,并写入下标;对于”嵌套表达式”类型,递归解析简单来说,Build流程使用深度优先遍历将树形结构的逻辑表达式,平铺成了数组.使用编辑器构造query对象底层逻辑与使用C++构造一致,只不过由于FGameplayTagQueryExpression不是USTRUCT,以及当时InstancedStruct还没诞生,所以对它用UObject”镜像”了一遍(个人猜测),所以有了UEditableGameplayTagQueryExpression以及相关类型,以支持编辑时的表达式嵌套,提供了更好的调试信息,参照FGameplayTagQuery::BuildFromEditableQueryFGameplayTagQuery::Matches, 检验逻辑表达式使用了辅助类型FQueryEvaluator,持有TagQuery的不可变引用,记录当前元数据下标和检测是否有读取错误.根据读取到的表达式类型,执行对应的逻辑判定.每次读取元数据都会检测是否存在读取错误.参照FQueryEvaluator::EvalExpr结语感觉FGameplayTagQuery的实现比较巧妙,提供了强大的匹配逻辑,适合任意需要Tag匹配功能的需求,不过其中的编辑器逻辑存在代码重复,不够优雅,以及对读取错误的检测并不严谨,后续频繁的检测也就不太必要了.但总体上瑕不掩瑜"
  },
  
  {
    "title": "一种把多个虚幻工程解决方案合而为一的方法",
    "url": "/posts/A-way-to-combine-multiple-unreal-projects-into-one/",
    "categories": "Unreal Engine",
    "tags": "tooling",
    "date": "2022-06-05 11:15:13 +0800",
    





    
    "snippet": "使用引擎目录的GenerateProjectFiles.bat和.uprojectdirs文件  首先参考Default.uprojectdirs文件中的注释  新建my.uprojectdirs或直接修改Default.uprojectdirs文件,并写入例如Project/  此时运行GenerateProjectFiles.bat生成解决方案时,会额外从引擎目录/Project目录下的...",
    "content": "使用引擎目录的GenerateProjectFiles.bat和.uprojectdirs文件  首先参考Default.uprojectdirs文件中的注释  新建my.uprojectdirs或直接修改Default.uprojectdirs文件,并写入例如Project/  此时运行GenerateProjectFiles.bat生成解决方案时,会额外从引擎目录/Project目录下的1级子目录寻找虚幻工程目录, 例如UnrealEngine/Project/LyraGame  完成  因为.uprojectdirs文件中只支持指定子目录,若想要外部目录的工程也被包含进解决方案文件,可以使用系统提供的symbol-link功能  已废弃方法  初衷  因为工作,学习的原因,我本地会有多个虚幻工程,并且它们共用了同一个引擎  它们的工程文件默认都是由UBT(Unreal Build Tool)生成的,独立的解决方案文件  这给我带来的一些问题:            由于打开解决方案的成本较高,同时打开多个解决方案时的等待时间,内存占用可能都是成倍增加的              在IDE抽风,或者引擎代码更新而触发符号重新解析的时候,等待时间少则15分钟起步,那叫一个折磨        我认为不同解决方案中,物理路径相同的工程,应该视为同一个工程,虚幻引擎的工程不应该在每个解决方案都重新解析一遍  但目前用过的Rider和Visual Studio(宇宙第一IDE)都是会在每个解决方案中重新解析一遍.非常折磨,其中原由,令人费解,希望能有大佬告知一下  需求  所以我就在想,既然这些个IDE这么”愚笨”,靠不住,那我能否找到一个方法,手动把多个解决方案合成一个呢?  步骤  下面分享的是,我使用Rider时的操作步骤:            在想要多开的解决方案中,随意选择一个作为”主解决方案“,并打开              添加其它工程文件                  在Explorer解决方案浏览器中,右键任意工程文件夹,比如Games,选择Add,Add Existing Project...,然后选择相关的工程文件              假如要添加的工程是LyraStarterGame,那么它的工程文件应该位于LyraStarterGame_Folder\\\\Intermediate\\\\ProjectFiles\\\\LyraStarterGame.vcxproj            在”解决方案配置”中,修改刚刚添加的工程的配置              点击右上角的工具栏中的DebugGameEditor | Win64按钮(这是我的解决方案编译配置,根据你的实际情况,文字会有所不同),然后选择Edit Solution Comfigurations...              找到刚刚添加的工程,可以看到它们当前都是默认的配置,可能是DebugClient | Arm64什么的,把它改成你需要的配置,一般是与解决方案编译配置一致            修改工程文件参数              回到Explorer解决方案浏览器              右键刚刚添加的工程(这里我拿LyraStarterGame举例),选择Edit,Edit LyraStarterGame.vcxproj              将LyraStarterGame.vcxproj文件中所有$(SolutionDir)替换为$(ProjectDir)..\\\\..\\\\ ($(SolutionDir)是当前解决方案的根目录,$(ProjectDir)是当前工程的工程文件所在目录,即LyraStarterGame_Folder\\\\Intermediate\\\\ProjectFiles\\\\,所以这里使用两次..\\\\,获得了当前工程的根目录)              如果不想一次性全都替换,也可以搜索你的”编译配置“,比如 DebugGame_Editor|x64,找到对应编译配置的相关配置,只替换三个NMake相关的命令行中的文本,但可能会存在工程文件无法正常解析符号的问题:比如Switch Header/Source功能无法使用,语法着色失效等,如遇到问题,进行全量替换即可        不足  每次通过UBT重新生成解决方案文件时,相关的工程文件会被覆盖,上面的操作需要重新执行一次.如果能有IDE的支持,或者自动化的工具就好了"
  }
  
]

